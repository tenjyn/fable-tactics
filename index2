<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stat-Chess (HP/ATK/DEF/MOVE)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/chessboard-1.0.0.min.css" />
<style>
  body { font-family: system-ui, Arial, sans-serif; max-width: 900px; margin: 20px auto; padding: 0 12px; }
  #topbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  #board { width: 520px; margin: 12px 0; position: relative; }
  #side { flex:1; min-width:260px; }
  .wrap { display:flex; gap:24px; flex-wrap:wrap; }
  .stat { display:inline-block; padding:2px 6px; border-radius:4px; background:#f3f3f3; margin-right:6px; font-size: 13px; }
  .status { margin-top: 8px; min-height: 24px; }
  .hp-badge { position:absolute; right:2px; bottom:2px; font-size:11px; background:rgba(0,0,0,0.65); color:#fff; padding:0 4px; border-radius:3px; }
  .legal { box-shadow: inset 0 0 0 3px rgba(0, 128, 255, 0.5) !important; }
  .enemy { box-shadow: inset 0 0 0 3px rgba(255, 64, 64, 0.5) !important; }
  .panel { border:1px solid #ddd; border-radius:8px; padding:12px; background:#fafafa; }
  .tiny { font-size: 12px; opacity: 0.8; }
  button { cursor:pointer; }
</style>
</head>
<body>
  <h1>Stat-Chess</h1>
  <div id="topbar">
    <button id="new">New Game</button>
    <button id="flip">Flip Board</button>
    <span class="status" id="turn"></span>
  </div>

  <div class="wrap">
    <div id="board"></div>

    <div id="side" class="panel">
      <h3>Selected</h3>
      <div id="selected">None</div>
      <h3>Log</h3>
      <div id="log" class="tiny"></div>
      <h3>Rules (short)</h3>
      <ul class="tiny">
        <li>Move like standard chess (no castling/promo/en passant).</li>
        <li>Sliding pieces (R/B/Q) are capped by their <b>MOVE</b> stat.</li>
        <li>Attack by moving onto an enemy. Damage = max(1, ATK − DEF).</li>
        <li>If the defender survives, the attacker bounces back to its origin.</li>
        <li>Win by defeating the enemy King.</li>
      </ul>
    </div>
  </div>

  <div class="status" id="status"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/chessboard-1.0.0.min.js"></script>
  <script>
  // ---------- Data Model ----------
  const initialSetup = () => ({
    // board: map square -> pieceId (e.g., "e2" -> "wP#2")
    pos: {
      a2:'wP#1', b2:'wP#2', c2:'wP#3', d2:'wP#4', e2:'wP#5', f2:'wP#6', g2:'wP#7', h2:'wP#8',
      a1:'wR#1', b1:'wN#1', c1:'wB#1', d1:'wQ#1', e1:'wK#1', f1:'wB#2', g1:'wN#2', h1:'wR#2',
      a7:'bP#1', b7:'bP#2', c7:'bP#3', d7:'bP#4', e7:'bP#5', f7:'bP#6', g7:'bP#7', h7:'bP#8',
      a8:'bR#1', b8:'bN#1', c8:'bB#1', d8:'bQ#1', e8:'bK#1', f8:'bB#2', g8:'bN#2', h8:'bR#2',
    },
    // pieces: id -> stats and type
    pieces: {
      // White
      'wK#1': makePiece('w','K',{hp:10, atk:3, def:2}),
      'wQ#1': makePiece('w','Q',{hp:7,  atk:5, def:1, move:7}),
      'wR#1': makePiece('w','R',{hp:6,  atk:4, def:2, move:7}),
      'wR#2': makePiece('w','R',{hp:6,  atk:4, def:2, move:7}),
      'wB#1': makePiece('w','B',{hp:5,  atk:3, def:1, move:7}),
      'wB#2': makePiece('w','B',{hp:5,  atk:3, def:1, move:7}),
      'wN#1': makePiece('w','N',{hp:5,  atk:3, def:2}),
      'wN#2': makePiece('w','N',{hp:5,  atk:3, def:2}),
      'wP#1': makePiece('w','P',{hp:3,  atk:2, def:0}),
      'wP#2': makePiece('w','P',{hp:3,  atk:2, def:0}),
      'wP#3': makePiece('w','P',{hp:3,  atk:2, def:0}),
      'wP#4': makePiece('w','P',{hp:3,  atk:2, def:0}),
      'wP#5': makePiece('w','P',{hp:3,  atk:2, def:0}),
      'wP#6': makePiece('w','P',{hp:3,  atk:2, def:0}),
      'wP#7': makePiece('w','P',{hp:3,  atk:2, def:0}),
      'wP#8': makePiece('w','P',{hp:3,  atk:2, def:0}),
      // Black
      'bK#1': makePiece('b','K',{hp:10, atk:3, def:2}),
      'bQ#1': makePiece('b','Q',{hp:7,  atk:5, def:1, move:7}),
      'bR#1': makePiece('b','R',{hp:6,  atk:4, def:2, move:7}),
      'bR#2': makePiece('b','R',{hp:6,  atk:4, def:2, move:7}),
      'bB#1': makePiece('b','B',{hp:5,  atk:3, def:1, move:7}),
      'bB#2': makePiece('b','B',{hp:5,  atk:3, def:1, move:7}),
      'bN#1': makePiece('b','N',{hp:5,  atk:3, def:2}),
      'bN#2': makePiece('b','N',{hp:5,  atk:3, def:2}),
      'bP#1': makePiece('b','P',{hp:3,  atk:2, def:0}),
      'bP#2': makePiece('b','P',{hp:3,  atk:2, def:0}),
      'bP#3': makePiece('b','P',{hp:3,  atk:2, def:0}),
      'bP#4': makePiece('b','P',{hp:3,  atk:2, def:0}),
      'bP#5': makePiece('b','P',{hp:3,  atk:2, def:0}),
      'bP#6': makePiece('b','P',{hp:3,  atk:2, def:0}),
      'bP#7': makePiece('b','P',{hp:3,  atk:2, def:0}),
      'bP#8': makePiece('b','P',{hp:3,  atk:2, def:0}),
    },
    turn: 'w',
    selected: null,
    flipped: false,
    over: false,
    log: []
  });

  function makePiece(color, kind, stats) {
    return {
      id: null, // filled by key in pieces
      color, kind,
      hp: stats.hp,
      atk: stats.atk,
      def: stats.def,
      move: stats.move || 0 // sliding range cap (R/B/Q)
    };
  }

  // ---------- Board UI ----------
  let board, S = initialSetup();
  hydrateIds();

  board = Chessboard('board', {
    position: toBoardPosition(S),
    draggable: true,
    onDragStart: onDragStart,
    onDrop: onDrop,
    onSnapEnd: onSnapEnd,
    pieceTheme: pieceTheme
  });

  renderHUD();
  drawOverlays();

  document.getElementById('new').onclick = () => { S = initialSetup(); hydrateIds(); board.position(toBoardPosition(S)); renderHUD(); drawOverlays(); };
  document.getElementById('flip').onclick = () => { S.flipped = !S.flipped; board.flip(); };

  function pieceTheme(pieceCode) {
    // chessboard.js expects like 'wP', 'bK'
    const c = pieceCode[0] === 'w' ? 'w' : 'b';
    const t = pieceCode[1].toUpperCase();
    // Using CDN sprites
    return `https://cdnjs.cloudflare.com/ajax/libs/chessboard.js/1.0.0/img/chesspieces/wikipedia/${c}${t}.png`;
  }

  function onDragStart(source, piece, pos, orientation) {
    if (S.over) return false;
    const color = piece[0]; // 'w' or 'b'
    if (color !== S.turn) return false;
    const pid = findPieceAt(source);
    if (!pid) return false;
    S.selected = pid;
    highlightLegal(pid);
  }

  function onDrop(source, target) {
    clearHighlights();
    const pid = S.selected;
    S.selected = null;
    if (!pid) return 'snapback';

    const legal = legalMoves(pid);
    const mv = legal.find(m => m.from === source && m.to === target);
    if (!mv) return 'snapback';

    // Execute move or attack
    const before = cloneState(S);
    const attacker = S.pieces[pid];
    const defId = S.pos[target];

    if (!defId) {
      // Simple move
      movePiece(pid, target);
      log(`${prettyPiece(attacker)} to ${target}`);
    } else {
      // Attack
      const defender = S.pieces[defId];
      const dmg = Math.max(1, attacker.atk - defender.def);
      defender.hp -= dmg;

      if (defender.hp <= 0) {
        delete S.pos[target];
        movePiece(pid, target);
        log(`${prettyPiece(attacker)} attacks ${prettyPiece(defender)} at ${target} for ${dmg} — defeated`);
        if (defender.kind === 'K') endGame(`${attacker.color === 'w' ? 'White' : 'Black'} wins (king defeated)`);
      } else {
        // Defender survives: bounce back, do not move piece
        log(`${prettyPiece(attacker)} attacks ${prettyPiece(defender)} at ${target} for ${dmg} — ${defender.hp} HP left`);
      }
    }

    // Swap turn (unless game ended)
    if (!S.over) S.turn = (S.turn === 'w') ? 'b' : 'w';

    board.position(toBoardPosition(S));
    renderHUD();
    drawOverlays();
  }

  function onSnapEnd() {
    board.position(toBoardPosition(S));
  }

  // ---------- Movement Logic ----------
  const files = ['a','b','c','d','e','f','g','h'];
  function sqToRC(sq){ return [8 - parseInt(sq[1]), files.indexOf(sq[0])]; }
  function rcToSq(r,c){ return files[c] + (8 - r); }
  function inBounds(r,c){ return r>=0 && r<8 && c>=0 && c<8; }

  function legalMoves(pid){
    const from = findSquare(pid); if (!from) return [];
    const p = S.pieces[pid];
    const [r,c] = sqToRC(from);
    const enemy = (color) => (color === 'w' ? 'b' : 'w');

    const moves = [];
    const push = (toR, toC, stopOnBlock=true, cap=true) => {
      if (!inBounds(toR,toC)) return 'stop';
      const toSq = rcToSq(toR,toC);
      const occ = S.pos[toSq];
      if (!occ){ moves.push({from, to:toSq}); return 'cont'; }
      const occP = S.pieces[occ];
      if (occP.color === p.color) return 'stop';
      // enemy there
      if (cap){ moves.push({from, to:toSq}); }
      return 'stop';
    };

    if (p.kind === 'P'){
      const dir = p.color==='w' ? 1 : -1;
      // forward
      const fr = r - dir;
      if (inBounds(fr,c) && !S.pos[rcToSq(fr,c)]) moves.push({from, to: rcToSq(fr,c)});
      // captures
      for (const dc of [-1,1]) {
        const tr = r - dir, tc = c + dc;
        if (!inBounds(tr,tc)) continue;
        const sq = rcToSq(tr,tc);
        if (S.pos[sq] && S.pieces[S.pos[sq]].color !== p.color) moves.push({from, to: sq});
      }
    }
    if (p.kind === 'N'){
      const deltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
      for (const [dr,dc] of deltas){
        const tr=r+dr, tc=c+dc;
        if (!inBounds(tr,tc)) continue;
        const sq = rcToSq(tr,tc);
        const occ = S.pos[sq];
        if (!occ || S.pieces[occ].color !== p.color) moves.push({from, to:sq});
      }
    }
    const ray = (dirs, cap, rangeCap=7) => {
      for (const [dr,dc] of dirs){
        let steps=0, tr=r, tc=c;
        while (true){
          tr+=dr; tc+=dc; steps++;
          if (steps > rangeCap) break;
          const res = push(tr,tc,true,cap);
          if (res==='stop') break;
        }
      }
    };
    if (p.kind === 'B') ray([[1,1],[1,-1],[-1,1],[-1,-1]], true, p.move||7);
    if (p.kind === 'R') ray([[1,0],[-1,0],[0,1],[0,-1]], true, p.move||7);
    if (p.kind === 'Q') ray([[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]], true, p.move||7);
    if (p.kind === 'K'){
      for (let dr=-1; dr<=1; dr++){
        for (let dc=-1; dc<=1; dc++){
          if (dr===0 && dc===0) continue;
          const tr=r+dr, tc=c+dc;
          if (!inBounds(tr,tc)) continue;
          const sq=rcToSq(tr,tc);
          const occ=S.pos[sq];
          if (!occ || S.pieces[occ].color !== p.color) moves.push({from, to:sq});
        }
      }
    }
    // Filter out moves that would put own king on already-occupied enemy square and bounce? (not needed here)
    return moves;
  }

  // ---------- Helpers ----------
  function findSquare(pid){ for (const [sq,id] of Object.entries(S.pos)) if (id===pid) return sq; return null; }
  function findPieceAt(sq){ return S.pos[sq] || null; }
  function movePiece(pid, to){
    const from = findSquare(pid);
    if (from) delete S.pos[from];
    S.pos[to] = pid;
  }
  function toBoardPosition(state){
    // chessboard.js wants e.g., { e2: 'wP', e7: 'bP', ... }
    const map = {};
    for (const [sq,id] of Object.entries(state.pos)){
      const p = state.pieces[id];
      map[sq] = p.color + p.kind;
    }
    return map;
  }
  function prettyPiece(p){ const names = {K:'King',Q:'Queen',R:'Rook',B:'Bishop',N:'Knight',P:'Pawn'}; return `${p.color==='w'?'White':'Black'} ${names[p.kind]}`; }
  function endGame(msg){ S.over=true; setStatus(msg); }
  function log(msg){ S.log.unshift(msg); if (S.log.length>40) S.log.pop(); document.getElementById('log').innerHTML = S.log.map(l=>`• ${l}`).join('<br>'); }
  function setStatus(t){ document.getElementById('status').textContent = t; }

  function renderHUD(){
    const turnEl = document.getElementById('turn');
    turnEl.textContent = S.over ? 'Game Over' : `${S.turn==='w'?'White':'Black'} to move`;
    document.getElementById('selected').innerHTML = 'None';
  }

  function hydrateIds(){
    for (const [id,p] of Object.entries(S.pieces)) p.id = id;
  }

  // ---------- Visual Overlays (HP badges & legal highlights) ----------
  function drawOverlays(){
    // Clear prior badges
    const squares = document.querySelectorAll('#board .square-55d63');
    squares.forEach(el => {
      const badge = el.querySelector('.hp-badge');
      if (badge) badge.remove();
    });
    // Add HP badges
    for (const [sq,id] of Object.entries(S.pos)){
      const p = S.pieces[id];
      const el = document.querySelector(`#board .square-${sq}`);
      if (!el) continue;
      const b = document.createElement('div');
      b.className = 'hp-badge';
      b.textContent = `HP ${p.hp}  A${p.atk} D${p.def}${p.move?` M${p.move}`:''}`;
      el.appendChild(b);
    }
  }

  function highlightLegal(pid){
    clearHighlights();
    const ls = legalMoves(pid);
    const mySq = findSquare(pid);
    const me = document.querySelector(`#board .square-${mySq}`);
    if (me) me.classList.add('legal');
    for (const m of ls){
      const el = document.querySelector(`#board .square-${m.to}`);
      if (!el) continue;
      if (S.pos[m.to] && S.pieces[S.pos[m.to]].color !== S.pieces[pid].color) el.classList.add('enemy');
      else el.classList.add('legal');
    }
    // show selected panel
    const p = S.pieces[pid];
    document.getElementById('selected').innerHTML =
      `<div class="stat"><b>${prettyPiece(p)}</b></div>
       <div class="stat">HP ${p.hp}</div>
       <div class="stat">ATK ${p.atk}</div>
       <div class="stat">DEF ${p.def}</div>
       ${p.move?`<div class="stat">MOVE ${p.move}</div>`:''}
       <div>Square: <b>${mySq}</b></div>`;
  }

  function clearHighlights(){
    document.querySelectorAll('#board .square-55d63').forEach(el => el.classList.remove('legal','enemy'));
  }

  function cloneState(s){
    return JSON.parse(JSON.stringify(s)); // handy if you want undo later
  }
  </script>
</body>
</html>